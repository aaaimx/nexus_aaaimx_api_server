import { IEventRepository } from "@/domain/repositories/event.repository";
import { Event, EventSession } from "@/domain/entities/event.entity";
import AppException from "@/shared/utils/exception.util";

export class EventBusinessService {
  constructor(private readonly eventRepository: IEventRepository) {}

  /**
   * Generates event sessions for multi-day and recurring events
   */
  async generateEventSessions(event: Event): Promise<EventSession[]> {
    const sessions: EventSession[] = [];

    if (event.eventType === "SINGLE") {
      // Single events don't need sessions
      return sessions;
    }

    if (event.eventType === "COURSE" || event.eventType === "WORKSHOP") {
      // Generate sessions for each day between start and end date
      sessions.push(...this.generateMultiDaySessions(event));
    }

    if (event.eventType === "RECURRING" && event.isRecurring) {
      // Generate sessions based on recurrence pattern
      sessions.push(...this.generateRecurringSessions(event));
    }

    // Save sessions to database
    for (const session of sessions) {
      await this.eventRepository.createEventSession(session);
    }

    return sessions;
  }

  /**
   * Generates sessions for multi-day events (COURSE/WORKSHOP)
   */
  private generateMultiDaySessions(event: Event): EventSession[] {
    const sessions: EventSession[] = [];

    if (
      !event.startDate ||
      !event.endDate ||
      !event.startTime ||
      !event.endTime
    ) {
      return sessions;
    }

    const currentDate = new Date(event.startDate);
    const endDate = new Date(event.endDate);

    while (currentDate <= endDate) {
      sessions.push({
        id: "", // Will be generated by database
        eventId: event.id,
        sessionDate: new Date(currentDate),
        startTime: event.startTime,
        endTime: event.endTime,
        isCancelled: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      currentDate.setDate(currentDate.getDate() + 1);
    }

    return sessions;
  }

  /**
   * Generates sessions for recurring events
   */
  private generateRecurringSessions(event: Event): EventSession[] {
    const sessions: EventSession[] = [];

    if (
      !event.recurrencePattern ||
      !event.recurrenceStartDate ||
      !event.recurrenceEndDate ||
      !event.startTime ||
      !event.endTime
    ) {
      return sessions;
    }

    const startDate = new Date(event.recurrenceStartDate);
    const endDate = new Date(event.recurrenceEndDate);
    const interval = event.recurrenceInterval || 1;

    let currentDate = new Date(startDate);

    while (currentDate <= endDate) {
      let shouldIncludeDate = false;

      switch (event.recurrencePattern) {
      case "DAILY":
        shouldIncludeDate = true;
        break;
      case "WEEKLY":
        shouldIncludeDate = this.isWeeklyMatch(
          currentDate,
          startDate,
          interval
        );
        break;
      case "MONTHLY":
        shouldIncludeDate = this.isMonthlyMatch(
          currentDate,
          startDate,
          interval
        );
        break;
      case "CUSTOM":
        shouldIncludeDate = this.isCustomMatch(
          currentDate,
          event.recurrenceDays
        );
        break;
      }

      if (shouldIncludeDate) {
        sessions.push({
          id: "", // Will be generated by database
          eventId: event.id,
          sessionDate: new Date(currentDate),
          startTime: event.startTime,
          endTime: event.endTime,
          isCancelled: false,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
      }

      currentDate.setDate(currentDate.getDate() + 1);
    }

    return sessions;
  }

  /**
   * Checks if a date matches weekly recurrence pattern
   */
  private isWeeklyMatch(
    currentDate: Date,
    startDate: Date,
    interval: number
  ): boolean {
    const daysDiff = Math.floor(
      (currentDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)
    );
    return daysDiff % (7 * interval) === 0;
  }

  /**
   * Checks if a date matches monthly recurrence pattern
   */
  private isMonthlyMatch(
    currentDate: Date,
    startDate: Date,
    interval: number
  ): boolean {
    const monthsDiff =
      (currentDate.getFullYear() - startDate.getFullYear()) * 12 +
      (currentDate.getMonth() - startDate.getMonth());
    return (
      monthsDiff % interval === 0 &&
      currentDate.getDate() === startDate.getDate()
    );
  }

  /**
   * Checks if a date matches custom recurrence pattern
   */
  private isCustomMatch(currentDate: Date, recurrenceDays?: string): boolean {
    if (!recurrenceDays) return false;

    const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
    const targetDays = recurrenceDays.split(",").map((d) => parseInt(d.trim()));

    // Convert Sunday (0) to 7 for consistency with business rules
    const normalizedDay = dayOfWeek === 0 ? 7 : dayOfWeek;

    return targetDays.includes(normalizedDay);
  }

  /**
   * Cancels all sessions for a recurring event
   */
  async cancelAllEventSessions(
    eventId: string,
    reason?: string
  ): Promise<void> {
    const sessions = await this.eventRepository.findEventSessions(eventId);

    for (const session of sessions) {
      const updateData: Partial<EventSession> = {
        isCancelled: true,
      };
      if (reason !== undefined) {
        updateData.cancellationReason = reason;
      }
      await this.eventRepository.updateEventSession(session.id, updateData);
    }
  }

  /**
   * Updates attendee status for all sessions of a recurring event
   */
  async updateRecurringEventAttendance(
    userId: string,
    eventId: string,
    status: "REGISTERED" | "CANCELLED"
  ): Promise<void> {
    const attendance = await this.eventRepository.findUserEventAttendance(
      userId,
      eventId
    );

    if (attendance) {
      await this.eventRepository.updateEventAttendee(attendance.id, { status });
    } else if (status === "REGISTERED") {
      await this.eventRepository.createEventAttendee({
        userId,
        eventId,
        status,
      });
    }
  }

  /**
   * Checks if an event has available slots
   */
  async hasAvailableSlots(event: Event): Promise<boolean> {
    if (!event.maxParticipants) return true;

    const currentAttendees = await this.eventRepository.countEventAttendees(
      event.id
    );
    return currentAttendees < event.maxParticipants;
  }

  /**
   * Gets event statistics
   */
  async getEventStatistics(eventId: string): Promise<{
    totalAttendees: number;
    registeredAttendees: number;
    cancelledAttendees: number;
    availableSlots?: number;
  }> {
    const attendees = await this.eventRepository.findEventAttendees(eventId);
    const event = await this.eventRepository.findById(eventId);

    if (!event) {
      throw new AppException("Event not found", 404);
    }

    const registeredAttendees = attendees.filter(
      (a) => a.status === "REGISTERED"
    ).length;
    const cancelledAttendees = attendees.filter(
      (a) => a.status === "CANCELLED"
    ).length;

    const stats: {
      totalAttendees: number;
      registeredAttendees: number;
      cancelledAttendees: number;
      availableSlots?: number;
    } = {
      totalAttendees: attendees.length,
      registeredAttendees,
      cancelledAttendees,
    };

    if (event.maxParticipants) {
      stats.availableSlots = event.maxParticipants - registeredAttendees;
    }

    return stats;
  }

  /**
   * Validates if user can register for event
   */
  async canUserRegister(
    userId: string,
    eventId: string
  ): Promise<{
    canRegister: boolean;
    reason?: string;
  }> {
    const event = await this.eventRepository.findById(eventId);

    if (!event) {
      return { canRegister: false, reason: "Event not found" };
    }

    if (event.status !== "PUBLISHED" && event.status !== "ONLINE") {
      return {
        canRegister: false,
        reason: "Event is not available for registration",
      };
    }

    // Check if user is already registered
    const existingAttendance =
      await this.eventRepository.findUserEventAttendance(userId, eventId);
    if (existingAttendance && existingAttendance.status === "REGISTERED") {
      return {
        canRegister: false,
        reason: "User is already registered for this event",
      };
    }

    // Check available slots
    const hasSlots = await this.hasAvailableSlots(event);
    if (!hasSlots) {
      return {
        canRegister: false,
        reason: "Event has reached maximum participants",
      };
    }

    return { canRegister: true };
  }
}
